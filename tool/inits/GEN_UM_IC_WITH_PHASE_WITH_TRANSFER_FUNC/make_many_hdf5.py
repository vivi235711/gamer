#!/usr/bin/env python3.7

import sys, subprocess, random, h5py
import numpy as np

def OVER_WRITE_MUSIC_INFILE(keyword, value, rewrite):
   if rewrite:
      handle = '-i'
   else:
      handle = '-e'

   if 'level' in keyword:
      cmd = 'sed %s "s/^%s.*/%s = %d/g" %s'%(handle, keyword, keyword, value, music_input_file)
   elif keyword == 'padding':
      cmd = 'sed %s "s/^%s.*/%s = %d/g" %s'%(handle, keyword, keyword, value, music_input_file)
   elif keyword == 'seed':
      cmd = 'sed %s "s/^seed.*/seed[%d] = %d/g" %s'%(handle, level,value, music_input_file)
   elif keyword == 'filename':
      cmd = 'sed %s "s/^%s.*/%s = %s/g" %s'%(handle, keyword, keyword, value, music_input_file)
   else:
      cmd = 'sed %s "s/^%s.*/%s = %.6e/g" %s'%(handle, keyword, keyword, value, music_input_file)
   if rewrite:
      _ = subprocess.check_output(cmd, shell=True).decode('utf-8')
   else:
      test = subprocess.check_output(cmd, shell=True).decode('utf-8')
      print(test)

def CALCULATE_POWER(classifier, dens_k):
   power = abs(np.array([dens_k[c[0],c[1],c[2]] for c in classifier]))**2. # obtain power for each (kx,ky,kz)
   return power.sum()/np.float64(power.shape[0])*boxlength**3.

boxlength    = 5.6 # Mpc/h
zstart       = 100.
level        = 9
ghost_zone   = 4
padding      = 0
total_sample = 1024
init_seed = 247642467
wave_vector_truncation = 4 # mulitple of base wave vecotr 2.*\pi/box_size
spectrum_save_path = "./spectrum_and_seed_for_wave_vector_truncation=%d_%d_sample.txt"%(wave_vector_truncation,total_sample)
music_input_file   = "./ics_example.conf"
music_hdf5_name    = "planck_2018_axion_m_22=0.2_tf_no_vel.hdf5"
music_log          = "./music_log_make_many_hdf5_wave_vector_truncation=%d_%d_sample"%(wave_vector_truncation,total_sample)
N_cell       = int(2**level)

# write columns name to spectrum_save_path
with open(spectrum_save_path,'w') as fw:
   fw.write("# sample_index\tseed\t")
   for i in range(1,wave_vector_truncation): # ignore DC mode
      fw.write("Power_%d*k_min\t"%i)
   fw.write("Power_%d*k_min\n"%wave_vector_truncation)

# initialize seed for RNG
random.seed(init_seed)

# write input to MUSIC input file
OVER_WRITE_MUSIC_INFILE('levelmin\ ', level, True)
OVER_WRITE_MUSIC_INFILE('levelmin_TF', level, True)
OVER_WRITE_MUSIC_INFILE('levelmax', level, True)
OVER_WRITE_MUSIC_INFILE('boxlength', boxlength, True)
OVER_WRITE_MUSIC_INFILE('zstart', zstart, True)
OVER_WRITE_MUSIC_INFILE('padding', padding, True)
OVER_WRITE_MUSIC_INFILE('filename', music_hdf5_name, True)

# make distance classifier
classifier_list = [] # construct a list to put wanted (kx,ky,kz) indices for each spectral indices (total number of spectral indices = wave_vector_truncation)
for i in range(wave_vector_truncation+1):
    classifier_list.append([])

kx, ky, kz = np.arange(N_cell), np.arange(N_cell), np.arange(N_cell//2+1)
kx[kx>(N_cell//2)] -= N_cell
ky[ky>(N_cell//2)] -= N_cell
#print(x, y, z)
kxx, kyy, kzz = np.meshgrid(kx,ky,kz,indexing='ij')
distance_in_filter = (np.round((kxx**2. + kyy**2. + kzz**2.)**0.5) <= wave_vector_truncation)
kx_in = np.array(kxx[distance_in_filter]) # possible kx value inside truncation wave_vector
ky_in = np.array(kyy[distance_in_filter]) # possible ky value inside truncation wave_vector
kz_in = np.array(kzz[distance_in_filter]) # possible kz value inside truncation wave_vector
#print(kx_in)
#print(ky_in)
#print(kz_in)

wave_vector_in_indices = np.round((kx_in**2. + ky_in**2. + kz_in**2.)**0.5).astype(np.int32) # corresponding spectral indices
#print(wave_vector_in_indices)
for i in range(len(wave_vector_in_indices)):
    classifier_list[wave_vector_in_indices[i]].append([kx_in[i],ky_in[i],kz_in[i]])  # put the (kx,ky,kz) into classifier_list[spectral_indices]

#### Test with known spectrum
#f = h5py.File('../run_1/planck_2018_axion_m_22=0.2_tf_no_vel.hdf5','r')
#density_hdf5 = np.swapaxes(f['level_008_DM_rho'][ghost_zone:-ghost_zone, ghost_zone:-ghost_zone, ghost_zone:-ghost_zone],0,2)
#density_k = np.fft.rfftn(density_hdf5)/N_cell**3.
#for i in range(1,wave_vector_truncation+1): # ignore DC mode
#   print(CALCULATE_POWER(classifier_list[i], density_k))

for idx_sample in range(total_sample):
   print("%d sampling starts..."%idx_sample)
# make seed at write to MUSIC input file
   random_seed = random.getrandbits(24) #use 24 bits to generate random number
   OVER_WRITE_MUSIC_INFILE('seed', random_seed, True)

# run MUSIC
   print("\tMUSIC runs...")
   cmd = './MUSIC %s >> %s'%(music_input_file, music_log)
   _ = subprocess.check_output(cmd, shell=True).decode('utf-8')
   print("\tMUSIC finished")

# load hdf5 generated by MUSIC
   with h5py.File('./%s'%music_hdf5_name,'r') as f:
      density_hdf5 = np.swapaxes(f['level_%03d_DM_rho'%level][ghost_zone:-ghost_zone, ghost_zone:-ghost_zone, ghost_zone:-ghost_zone],0,2)
      print("Density array has shape ( %d,%d,%d )"%(density_hdf5.shape[0], density_hdf5.shape[1], density_hdf5.shape[2]))
      f.close()

# analysis spectrum
   print("\tSpectrum analysis starts...")
   density_k = np.fft.rfftn(density_hdf5)/N_cell**3.
   PS_selected = np.zeros(wave_vector_truncation)
   for i in range(1,wave_vector_truncation+1): # ignore DC mode
      PS_selected[i-1] = CALCULATE_POWER(classifier_list[i], density_k) # save the i*k_min power at PS_selected[i-1]
   print("\tSpectrum analysis finished")
   
   with open(spectrum_save_path,'a') as fw:
      fw.write("%5d\t%10d\t"%(idx_sample,random_seed))
      for i in range(1,wave_vector_truncation): # ignore DC mode
         fw.write("%.8e\t"%PS_selected[i-1])
      fw.write("%.8e\n"%PS_selected[wave_vector_truncation-1])
   print("%d sampling finished\n--------------------------------------------------"%idx_sample)
